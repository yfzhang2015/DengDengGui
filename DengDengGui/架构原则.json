{
  "GRASP 通用职责分配软件模式 ": {
    "1. 信息专家 (Information Expert)": "为对象分配职责的通用原则 C 把职责分配给拥有足够信息可以履行职责的专家",
    "2. 创建者 (Creator)": "将创建 A 的职责赋给 B，如果至少下面一种情况为真：B“包含”或者聚合A ,B记录A的实例,B密切地使用A,B拥有A的初始化数据",
    "3. 低耦合 (Low Coupling)": "赋予职责使得对象间的耦合度尽可能低，最小化对象间的依赖和变更影响，最大化重用。",
    "4. 高内聚 (High Cohesion)": "赋予职责使得每个对象的职责尽可能保持聚焦和单一，易于管理和理解。",
    "5. 控制器 (Controller)": "把职责赋予系统、设备或者子系统的表示类 (门面控制器)，或者某个用例的表示类 (用例控制器)，让控制器接收事件并协调整个系统的运作。",
    "6. 多态 (Polymorphism)": "将职责分配给多个具有同名方法的多态子类，运行时根据需要动态切换子类，让系统行为变得可插拔。",
    "7. 纯虚构 (Pure Fabrication)": "针对真实问题域中不存在，但是设计建模中有用的概念，设计虚构类并赋予职责。",
    "8. 间接 (Indirection)": "在两个或者多个对象间有交互的情况下，为避免直接耦合，提高重用性，创建中间类并赋予职责，对象的交互交由中间类协调。",
    "9. 受保护的变化 (Protected Variation)": "简单讲就是封装变化。识别系统中可能的不稳定或者变化，在不稳定组件上创建稳定的抽象接口，将可能的变化封装在接口之后，使得系统内部的不稳定或者变化不会对系统的其它部分产生不良影响。"
  },
  "AKF架构原则":
  {
    "1.N + 1 设计": "永远不要少于两个，通常为三个。比方说无状态的 Web/API 一般部署至少>=2 个。",
    "2. 回滚设计": "确保系统可以回滚到以前发布过的任何版本。可以通过发布系统保留历史版本，或者代码中引入动态开关切换机制 (Feature Switch)。",
    "3. 禁用设计": "能够关闭任何发布的功能。新功能隐藏在动态开关机制 (Feature Switch) 后面，可以按需一键打开，如发现问题随时关闭禁用。",
    "4. 监控设计": "在设计阶段就必须考虑监控，而不是在实施完毕之后补充。例如在需求阶段就要考虑关键指标监控项，这就是度量驱动开发 (Metrics Driven Development) 的理念",
    "5. 设计多活数据中心": "不要被一个数据中心的解决方案把自己限制住。当然也要考虑成本和公司规模发展阶段。",
    "6. 使用成熟的技术": "只用确实好用的技术。商业组织毕竟不是研究机构，技术要落地实用，成熟的技术一般坑都被踩平了，新技术在完全成熟前一般需要踩坑躺坑",
    "7. 异步设计": "能异步尽量用异步，只有当绝对必要或者无法异步时，才使用同步调用。",
    "8. 无状态系统": "尽可能无状态，只有当业务确实需要，才使用状态。无状态系统易于扩展，有状态系统不易扩展且状态复杂时更易出错。",
    "9. 水平扩展而非垂直升级": "永远不要依赖更大、更快的系统。一般公司成长到一定阶段普遍经历过买更大、更快系统的阶段，即使淘宝当年也买小型机扛流量，后来扛不住才体会这样做不 scalable，所以才有后来的去 IOE 行动。",
    "10. 设计时至少要有两步前瞻性": "在扩展性问题发生前考虑好下一步的行动计划。架构师的价值就体现在这里，架构设计对于流量的增长要有提前量。",
    "11. 非核心则购买": "如果不是你最擅长，也提供不了差异化的竞争优势则直接购买。避免 Not Invented Here 症状，避免凡事都要重造轮子，毕竟达成业务目标才是重点。",
    "12. 使用商品化硬件": "在大多数情况下，便宜的就是最好的。这点和第 9 点是一致的，通过商品化硬件水平扩展，而不是买更大、更快的系统。",
    "13. 小构建、小发布和快试错": "全部研发要小构建，不断迭代，让系统不断成长。这个和微服务理念一致。",
    "14. 隔离故障": "实现故障隔离设计，通过断路保护避免故障传播和交叉影响。通过舱壁泳道等机制隔离失败单元 (Failure Unit)，一个单元的失败不至影响其它单元的正常工作。",
    "15. 自动化": "设计和构建自动化的过程。如果机器可以做，就不要依赖于人。自动化是 DevOps 的基础。"
  }

}